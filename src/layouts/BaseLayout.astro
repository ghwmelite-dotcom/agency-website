---
import '@/styles/design-system.css';
import '@/styles/dark-mode-fixes.css';
import { SITE_CONFIG } from '@/config';
import LoadingScreen from '@/components/LoadingScreen.astro';
import CustomCursor from '@/components/CustomCursor.astro';
import Chatbot from '@/components/Chatbot.astro';
import PWAInstallPrompt from '@/components/PWAInstallPrompt.astro';
import SocialProof from '@/components/SocialProof.astro';

interface Props {
  title?: string;
  description?: string;
  image?: string;
  noLoader?: boolean;
  article?: {
    publishedTime?: string;
    modifiedTime?: string;
    author?: string;
    section?: string;
    tags?: string[];
  };
}

const {
  title = SITE_CONFIG.name,
  description = SITE_CONFIG.description,
  image = '/og-image.jpg',
  noLoader = false,
  article
} = Astro.props;

const pageTitle = title === SITE_CONFIG.name ? title : `${title} | ${SITE_CONFIG.name}`;
const siteUrl = Astro.url.origin;
const canonicalUrl = Astro.url.href;
const imageUrl = new URL(image, Astro.url).href;
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" id="favicon-link" />
    <meta name="generator" content={Astro.generator} />

    <!-- Primary Meta Tags -->
    <title>{pageTitle}</title>
    <meta name="title" content={pageTitle} />
    <meta name="description" content={description} />
    <meta name="author" content="WP Studios" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content={article ? "article" : "website"} />
    <meta property="og:site_name" content="WP Studios" />
    <meta property="og:url" content={canonicalUrl} />
    <meta property="og:title" content={pageTitle} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={imageUrl} />
    <meta property="og:image:secure_url" content={imageUrl} />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content={pageTitle} />
    <meta property="og:locale" content="en_US" />

    {article && (
      <>
        <meta property="article:published_time" content={article.publishedTime} />
        {article.modifiedTime && <meta property="article:modified_time" content={article.modifiedTime} />}
        {article.author && <meta property="article:author" content={article.author} />}
        {article.section && <meta property="article:section" content={article.section} />}
        {article.tags && article.tags.map((tag) => (
          <meta property="article:tag" content={tag} />
        ))}
      </>
    )}

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@ohwpstudios" />
    {article?.author && <meta name="twitter:creator" content={`@${article.author.toLowerCase().replace(/\s+/g, '')}`} />}
    <meta name="twitter:url" content={canonicalUrl} />
    <meta name="twitter:title" content={pageTitle} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={imageUrl} />
    <meta name="twitter:image:alt" content={pageTitle} />

    <!-- Fonts - Optimized with font-display:swap and preload -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" media="print" onload="this.media='all'" />
    <noscript><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" /></noscript>

    <!-- Critical Resource Hints -->
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />

    <!-- Performance & SEO -->
    <meta name="theme-color" content="#6366f1" />
    <meta name="msapplication-TileColor" content="#6366f1" />
    <link rel="canonical" href={Astro.url} />

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png" />
    <link rel="apple-touch-icon" sizes="128x128" href="/icons/icon-128x128.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png" />
    <link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png" />
    <link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png" />

    <!-- Apple Web App -->
    <meta name="apple-mobile-web-app-title" content="WP Studios" />

    <!-- Microsoft Tiles -->
    <meta name="msapplication-config" content="/browserconfig.xml" />

    <!-- Inline critical theme script -->
    <script is:inline>
      // Prevent flash of unstyled content
      const theme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', theme);

      // Load custom theme colors and fonts
      (async function() {
        try {
          const response = await fetch('/api/theme');
          const data = await response.json();

          if (data.success && data.settings) {
            const settings = data.settings;
            const root = document.documentElement;

            // Apply custom colors
            if (settings.color_primary) {
              root.style.setProperty('--color-primary', settings.color_primary);
              root.style.setProperty('--color-primary-dark', shadeColor(settings.color_primary, -20));
              root.style.setProperty('--color-primary-light', shadeColor(settings.color_primary, 20));
            }
            if (settings.color_secondary) {
              root.style.setProperty('--color-secondary', settings.color_secondary);
            }
            if (settings.color_accent) {
              root.style.setProperty('--color-accent', settings.color_accent);
            }
            if (settings.color_wordpress) {
              root.style.setProperty('--color-wordpress', settings.color_wordpress);
              root.style.setProperty('--color-wordpress-dark', shadeColor(settings.color_wordpress, -20));
              root.style.setProperty('--color-wordpress-light', shadeColor(settings.color_wordpress, 20));
            }

            // Update gradients
            if (settings.color_primary && settings.color_secondary) {
              root.style.setProperty('--gradient-primary', `linear-gradient(135deg, ${settings.color_primary} 0%, ${settings.color_secondary} 100%)`);
            }
            if (settings.color_wordpress) {
              root.style.setProperty('--gradient-wordpress', `linear-gradient(135deg, ${settings.color_wordpress} 0%, ${shadeColor(settings.color_wordpress, 20)} 100%)`);
            }

            // Load Google Fonts
            if (settings.font_heading || settings.font_body) {
              const fontsToLoad = new Set();
              if (settings.font_heading) fontsToLoad.add(settings.font_heading);
              if (settings.font_body) fontsToLoad.add(settings.font_body);

              const fontFamilies = Array.from(fontsToLoad).map(f => `family=${String(f).replace(/ /g, '+')}:wght@300;400;500;600;700;800`).join('&');
              const link = document.createElement('link');
              link.href = `https://fonts.googleapis.com/css2?${fontFamilies}&display=swap`;
              link.rel = 'stylesheet';
              document.head.appendChild(link);

              // Apply font families
              if (settings.font_heading) {
                root.style.setProperty('--font-display', `'${settings.font_heading}', ${root.style.getPropertyValue('--font-display') || 'sans-serif'}`);
              }
              if (settings.font_body) {
                root.style.setProperty('--font-sans', `'${settings.font_body}', ${root.style.getPropertyValue('--font-sans') || 'sans-serif'}`);
              }
            }
          }
        } catch (error) {
          console.log('Using default theme');
        }
      })();

      // Helper to darken/lighten colors
      function shadeColor(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
          (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
          .toString(16).slice(1);
      }
    </script>
  </head>
  <body>
    {!noLoader && <LoadingScreen />}
    <CustomCursor />
    <slot />
    <Chatbot />
    <SocialProof />
    <PWAInstallPrompt />

    <!-- Theme toggle script -->
    <script>
      function initTheme() {
        const themeToggle = document.querySelector('[data-theme-toggle]');

        if (themeToggle) {
          themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
          });
        }
      }

      // Run on initial load
      initTheme();

      // Re-run after view transitions
      document.addEventListener('astro:page-load', initTheme);
    </script>

    <!-- Intersection Observer for scroll animations -->
    <script>
      function initScrollAnimations() {
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add('animate-in');
                observer.unobserve(entry.target);
              }
            });
          },
          { threshold: 0.1, rootMargin: '0px 0px -50px 0px' }
        );

        document.querySelectorAll('[data-animate]').forEach((el) => {
          observer.observe(el);
        });
      }

      initScrollAnimations();
      document.addEventListener('astro:page-load', initScrollAnimations);
    </script>

    <!-- Dynamic Favicon -->
    <script>
      async function loadFavicon() {
        try {
          const response = await fetch('/api/admin/content');
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.content && data.content.site_favicon) {
              const faviconUrl = data.content.site_favicon.trim();
              if (faviconUrl !== '') {
                const faviconLink = document.getElementById('favicon-link') as HTMLLinkElement;
                if (faviconLink) {
                  faviconLink.href = faviconUrl;

                  // Update type based on file extension
                  if (faviconUrl.endsWith('.svg')) {
                    faviconLink.type = 'image/svg+xml';
                  } else if (faviconUrl.endsWith('.png')) {
                    faviconLink.type = 'image/png';
                  } else if (faviconUrl.endsWith('.ico')) {
                    faviconLink.type = 'image/x-icon';
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error loading favicon:', error);
        }
      }

      loadFavicon();
      document.addEventListener('astro:page-load', loadFavicon);
    </script>

    <!-- World-Class Animations System - Deferred for Performance -->
    <script src="/animations.js" defer></script>

    <!-- PWA Service Worker Registration -->
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {
              console.log('[PWA] Service Worker registered:', registration);

              // Check for updates every hour
              setInterval(() => {
                registration.update();
              }, 3600000);

              // Handle service worker updates
              registration.addEventListener('updatefound', () => {
                const newWorker = registration.installing;
                newWorker?.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // Show elegant update toast
                    const updateToast = document.getElementById('pwa-update-toast');
                    const reloadBtn = document.getElementById('pwa-reload');

                    if (updateToast) {
                      updateToast.classList.remove('hidden');
                    }

                    if (reloadBtn) {
                      reloadBtn.addEventListener('click', () => {
                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                        window.location.reload();
                      });
                    }
                  }
                });
              });
            })
            .catch((error) => {
              console.log('[PWA] Service Worker registration failed:', error);
            });

          // Handle service worker updates
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            window.location.reload();
          });
        });
      }

      // PWA Install Prompt - Modern Modal
      let deferredPrompt;
      const installModal = document.getElementById('pwa-install-modal');
      const installBtn = document.getElementById('pwa-install');
      const laterBtn = document.getElementById('pwa-later');
      const closeBtn = document.getElementById('pwa-close');

      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;

        // Show install modal after a delay if not dismissed
        if (!localStorage.getItem('pwa-install-dismissed')) {
          setTimeout(() => {
            if (installModal) {
              installModal.classList.remove('hidden');
            }
          }, 3000); // Show after 3 seconds
        }
      });

      // Handle install button
      if (installBtn) {
        installBtn.addEventListener('click', async () => {
          if (!deferredPrompt) return;

          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;

          if (outcome === 'accepted') {
            console.log('[PWA] User accepted the install prompt');
          } else {
            console.log('[PWA] User dismissed the install prompt');
          }

          deferredPrompt = null;
          if (installModal) {
            installModal.classList.add('hidden');
          }
        });
      }

      // Handle later/close buttons
      const dismissModal = () => {
        if (installModal) {
          installModal.classList.add('hidden');
        }
        localStorage.setItem('pwa-install-dismissed', 'true');
      };

      if (laterBtn) laterBtn.addEventListener('click', dismissModal);
      if (closeBtn) closeBtn.addEventListener('click', dismissModal);

      // Close modal on backdrop click
      if (installModal) {
        installModal.addEventListener('click', (e) => {
          if (e.target === installModal || e.target.classList.contains('pwa-modal-backdrop')) {
            dismissModal();
          }
        });
      }

      // Track PWA install
      window.addEventListener('appinstalled', () => {
        console.log('[PWA] App successfully installed');
        if (installModal) {
          installModal.classList.add('hidden');
        }
        localStorage.setItem('pwa-installed', 'true');

        // Optional: Send analytics event
        if (typeof gtag !== 'undefined') {
          gtag('event', 'pwa_install', {
            event_category: 'engagement',
            event_label: 'PWA Installed'
          });
        }
      });

      // Detect if running as PWA
      window.addEventListener('DOMContentLoaded', () => {
        const isPWA = window.matchMedia('(display-mode: standalone)').matches ||
                      window.navigator.standalone === true;

        if (isPWA) {
          document.documentElement.classList.add('pwa-mode');
          console.log('[PWA] Running as installed app');
        }
      });

      // Background sync for offline forms
      async function syncFormData(formData, url, method = 'POST') {
        if (!navigator.onLine) {
          // Store in IndexedDB for background sync
          try {
            const db = await openDB();
            const tx = db.transaction(['pending-forms'], 'readwrite');
            const store = tx.objectStore('pending-forms');

            await store.add({
              url,
              method,
              headers: { 'Content-Type': 'application/json' },
              data: formData,
              timestamp: Date.now()
            });

            // Register sync
            if ('sync' in registration) {
              await registration.sync.register('sync-form-data');
            }

            alert('You are offline. Form will be submitted when connection is restored.');
            return false;
          } catch (error) {
            console.error('[PWA] Failed to queue form:', error);
          }
        }
        return true;
      }

      function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('pwa-sync', 1);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('pending-forms')) {
              db.createObjectStore('pending-forms', { keyPath: 'id', autoIncrement: true });
            }
          };
        });
      }

      // Make syncFormData globally available
      window.syncFormData = syncFormData;

      // Connection Status Monitoring
      const connectionStatus = document.getElementById('pwa-connection-status');
      const statusText = connectionStatus?.querySelector('.pwa-status-text');
      let statusTimeout;

      function showConnectionStatus(isOnline) {
        if (!connectionStatus || !statusText) return;

        // Clear existing timeout
        if (statusTimeout) clearTimeout(statusTimeout);

        // Update status
        connectionStatus.classList.remove('hidden', 'online', 'offline');
        connectionStatus.classList.add(isOnline ? 'online' : 'offline');

        if (statusText) {
          statusText.textContent = isOnline ? 'Back Online' : 'You are Offline';
        }

        // Auto-hide after 3 seconds
        statusTimeout = setTimeout(() => {
          connectionStatus.classList.add('hidden');
        }, 3000);
      }

      // Listen for online/offline events
      window.addEventListener('online', () => {
        console.log('[PWA] Connection restored');
        showConnectionStatus(true);
      });

      window.addEventListener('offline', () => {
        console.log('[PWA] Connection lost');
        showConnectionStatus(false);
      });

      // Initial connection check
      if (!navigator.onLine) {
        showConnectionStatus(false);
      }

      // Push Notification Subscription Management
      async function setupPushNotifications() {
        // Check if push notifications are supported
        if (!('Notification' in window) || !('PushManager' in window)) {
          console.log('[Push] Push notifications not supported');
          return;
        }

        // Check if service worker is ready
        const registration = await navigator.serviceWorker.ready;
        if (!registration) {
          console.log('[Push] Service worker not ready');
          return;
        }

        // Check if already subscribed
        const existingSubscription = await registration.pushManager.getSubscription();

        // Determine user type based on current path
        const userType = window.location.pathname.startsWith('/admin/') ? 'admin' :
                        window.location.pathname.startsWith('/client/') ? 'client' : null;

        // Auto-subscribe admin users and logged-in client users
        const adminToken = localStorage.getItem('admin_token');
        const clientToken = localStorage.getItem('client_token');

        if (!existingSubscription && (adminToken || clientToken)) {
          // Request permission if not already granted
          if (Notification.permission === 'default') {
            const permission = await Notification.requestPermission();
            if (permission !== 'granted') {
              console.log('[Push] Notification permission denied');
              return;
            }
          }

          if (Notification.permission === 'granted') {
            try {
              await subscribeToPush(registration, userType || 'client');
            } catch (error) {
              console.error('[Push] Failed to subscribe:', error);
            }
          }
        } else if (existingSubscription) {
          console.log('[Push] Already subscribed to push notifications');
        }
      }

      async function subscribeToPush(registration, userType) {
        try {
          // Application server key (VAPID public key)
          // In production, this should come from environment variables
          // For now, using a placeholder - this needs to be generated
          const applicationServerKey = urlBase64ToUint8Array(
            'BEl62iUYgUivxIkv69yViEuiBIa-Ib27SaCH' +
            'goeJfaLHTU4kJP3H-FOcpfBEa-wGZtMh2wAQ' +
            '4BpQkJqFzZ8QiTM'
          );

          const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: applicationServerKey
          });

          console.log('[Push] Push subscription created:', subscription);

          // Send subscription to server
          const userId = userType === 'admin' ? 1 : null; // Get actual user ID from session

          const response = await fetch('/api/push/subscribe', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              subscription: subscription.toJSON(),
              userType: userType,
              userId: userId
            })
          });

          if (!response.ok) {
            throw new Error('Failed to save subscription to server');
          }

          const result = await response.json();
          console.log('[Push] Subscription saved to server:', result);

          // Store subscription ID locally
          localStorage.setItem('push_subscription_id', result.subscriptionId);

          return subscription;
        } catch (error) {
          console.error('[Push] Failed to subscribe:', error);
          throw error;
        }
      }

      function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
          .replace(/\-/g, '+')
          .replace(/_/g, '/');

        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);

        for (let i = 0; i < rawData.length; ++i) {
          outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
      }

      // Function to unsubscribe from push notifications
      async function unsubscribeFromPush() {
        try {
          const registration = await navigator.serviceWorker.ready;
          const subscription = await registration.pushManager.getSubscription();

          if (subscription) {
            const endpoint = subscription.endpoint;

            // Unsubscribe from browser
            await subscription.unsubscribe();

            // Unsubscribe from server
            await fetch('/api/push/unsubscribe', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ endpoint })
            });

            localStorage.removeItem('push_subscription_id');
            console.log('[Push] Unsubscribed from push notifications');
          }
        } catch (error) {
          console.error('[Push] Failed to unsubscribe:', error);
        }
      }

      // Make functions globally available
      window.subscribeToPush = setupPushNotifications;
      window.unsubscribeFromPush = unsubscribeFromPush;

      // Setup push notifications after service worker is registered
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.ready.then(() => {
          // Delay to avoid disrupting initial page load
          setTimeout(setupPushNotifications, 2000);
        });
      }
    </script>
  </body>
</html>
